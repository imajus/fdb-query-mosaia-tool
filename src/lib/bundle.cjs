"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const v=require("ethers"),le=require("alasql"),tr=require("csv-parse"),rr=require("@lit-protocol/encryption"),nr=require("@lit-protocol/lit-node-client-nodejs"),wt=require("@lit-protocol/constants"),Ae=require("@lit-protocol/auth-helpers"),or="0x0C168775d59D1238E2aB3eC4C7d1F587Ce0A4Dc7",ir=[{inputs:[{internalType:"address",name:"_paymentToken",type:"address"},{internalType:"address",name:"_pandoraServer",type:"address"}],stateMutability:"nonpayable",type:"constructor"},{inputs:[],name:"FDBRegistry__EmptyName",type:"error"},{inputs:[],name:"FDBRegistry__EmptySymbol",type:"error"},{inputs:[],name:"FDBRegistry__InsufficientAllowance",type:"error"},{inputs:[],name:"FDBRegistry__InsufficientBalance",type:"error"},{inputs:[],name:"FDBRegistry__InsufficientPayment",type:"error"},{inputs:[],name:"FDBRegistry__NotCollectionOwner",type:"error"},{inputs:[],name:"FDBRegistry__TransferFailed",type:"error"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"BalanceWithdrawn",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"nftContract",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"string",name:"name",type:"string"},{indexed:!1,internalType:"string",name:"symbol",type:"string"},{indexed:!1,internalType:"string",name:"description",type:"string"},{indexed:!1,internalType:"string",name:"privateColumns",type:"string"},{indexed:!1,internalType:"string",name:"publicColumns",type:"string"},{indexed:!1,internalType:"uint256",name:"price",type:"uint256"},{indexed:!0,internalType:"uint256",name:"collectionId",type:"uint256"}],name:"CollectionCreated",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"nftContract",type:"address"},{indexed:!1,internalType:"bool",name:"isActive",type:"bool"}],name:"CollectionStatusUpdated",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"nftContract",type:"address"},{indexed:!1,internalType:"uint256",name:"proofSetId",type:"uint256"},{indexed:!1,internalType:"string",name:"publicCid",type:"string"},{indexed:!1,internalType:"string",name:"privateCid",type:"string"},{indexed:!1,internalType:"bytes",name:"privateDataHash",type:"bytes"}],name:"DatasetLinked",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"nftContract",type:"address"},{indexed:!0,internalType:"address",name:"buyer",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"price",type:"uint256"}],name:"NFTPurchased",type:"event"},{inputs:[],name:"BASE_TOKEN_URI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[],name:"DEPLOYER_FEE_PERCENT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"RESERVE_PERIOD_DAYS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address[]",name:"recipients",type:"address[]"}],name:"batchMintNFTs",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"string",name:"description",type:"string"},{internalType:"string",name:"privateColumns",type:"string"},{internalType:"string",name:"publicColumns",type:"string"},{internalType:"uint256",name:"price",type:"uint256"}],name:"createCollection",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"getActiveCollections",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},{inputs:[],name:"getAllCollections",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"getCollectionEffectivePrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"getCollectionInfo",outputs:[{components:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"owner",type:"address"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"string",name:"description",type:"string"},{internalType:"string",name:"privateColumns",type:"string"},{internalType:"string",name:"publicColumns",type:"string"},{internalType:"uint256",name:"price",type:"uint256"},{internalType:"uint256",name:"createdAt",type:"uint256"},{internalType:"bool",name:"isActive",type:"bool"}],internalType:"struct FDBRegistry.Collection",name:"",type:"tuple"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"getCollectionLockupPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"getCollectionReserveCost",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"getDatasetInfo",outputs:[{components:[{internalType:"uint256",name:"proofSetId",type:"uint256"},{internalType:"string",name:"publicCid",type:"string"},{internalType:"string",name:"privateCid",type:"string"},{internalType:"bytes",name:"privateDataHash",type:"bytes"}],internalType:"struct FDBRegistry.Dataset",name:"",type:"tuple"}],stateMutability:"view",type:"function"},{inputs:[],name:"getPaymentToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},{inputs:[],name:"getTotalCollections",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getUserCollectionCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getUserCollections",outputs:[{components:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"owner",type:"address"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"string",name:"description",type:"string"},{internalType:"string",name:"privateColumns",type:"string"},{internalType:"string",name:"publicColumns",type:"string"},{internalType:"uint256",name:"price",type:"uint256"},{internalType:"uint256",name:"createdAt",type:"uint256"},{internalType:"bool",name:"isActive",type:"bool"}],internalType:"struct FDBRegistry.Collection[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"hasNFT",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"user",type:"address"}],name:"isCollectionOwner",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"uint256",name:"proofSetId",type:"uint256"},{internalType:"string",name:"publicCid",type:"string"},{internalType:"string",name:"privateCid",type:"string"},{internalType:"bytes",name:"dataHash",type:"bytes"}],name:"linkCollectionToDataset",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"mintNFT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"purchase",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"nftContract",type:"address"}],name:"toggleCollectionStatus",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}],et={address:or,abi:ir},sr="https://api.calibration.node.glif.io/rpc/v1";function mt(){return v.ethers.getDefaultProvider(sr)}function ue(){const r=mt();return new v.ethers.Wallet(process.env.ETHEREUM_PRIVATE_KEY,r)}class ar{constructor(e){this.abi=["function approve(address spender, uint256 amount) external returns (bool)","function balanceOf(address owner) external view returns (uint256)","function allowance(address owner, address spender) external view returns (uint256)"],this.contract=new v.ethers.Contract(e,this.abi,ue())}async approve(e,t){await(await this.contract.approve(e,t)).wait()}async balance(){const t=await ue().getAddress();return await this.contract.balanceOf(t)}async balanceOf(e){return await this.contract.balanceOf(e)}async allowance(e,t){return await this.contract.allowance(e,t)}}class Q{static instance=null;#e=null;constructor(){this.contract=new v.ethers.Contract(et.address,et.abi,ue())}static getInstance(){return this.instance||(this.instance=new Q),this.instance}async getPaymentToken(){if(!this.#e){const e=await this.contract.getPaymentToken();this.#e=new ar(e)}return this.#e}async listCollections(){const e=await this.contract.getActiveCollections();return Promise.all(e.map(async n=>{const o=await this.contract.getCollectionInfo(n),i=await this.contract.getCollectionEffectivePrice(n);return{address:o.nftContract,owner:o.owner,name:o.name,symbol:o.symbol,description:o.description,publicColumns:o.publicColumns,privateColumns:o.privateColumns,createdAt:o.createdAt.toString(),price:i}}))}async getCollectionInfo(e){const t=await this.contract.getCollectionInfo(e),n=await this.contract.getCollectionEffectivePrice(e);return{address:t.nftContract,owner:t.owner,name:t.name,symbol:t.symbol,description:t.description,publicColumns:t.publicColumns,privateColumns:t.privateColumns,price:n}}async getDatasetInfo(e){const t=await this.contract.getDatasetInfo(e),n=v.ethers.encodeBase64(v.ethers.getBytes(t.privateDataHash));return{address:t.nftContract,owner:t.owner,proofSetId:t.proofSetId,publicCid:t.publicCid,privateCid:t.privateCid,privateDataHash:n}}async purchase(e,t){if(!await this.contract.hasNFT(e)){const o=await this.getPaymentToken(),i=await o.balance();if(i<t){const a=v.ethers.formatUnits(i.toString(),18),c=v.ethers.formatUnits(t.toString(),18);throw new Error(`Insufficient balance: ${a} < ${c}`)}await o.approve(await this.contract.getAddress(),t),await(await this.contract.purchase(e)).wait()}}}function cr(r){const{Select:e,Table:t,Column:n,NumValue:o}=le.yy,i=le.parse(r),s=i.statements.find(a=>a instanceof e);if(!s)throw new Error("No SELECT statement found");return s.from=[new t({tableid:"?"})],s.columns=[...s.columns??[],new n({columnid:"cid"})],s.limit=new o({value:s.limit?.value??10}),i.toString()}function vt(r){return r.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function dr(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function ke(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function lr(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var o=0;o<r.length;o++){var i=r.charAt(o),s=i.charCodeAt(0);if(t[s]!==255)throw new TypeError(i+" is ambiguous");t[s]=o}var a=r.length,c=r.charAt(0),d=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var w=0,_=0,E=0,x=p.length;E!==x&&p[E]===0;)E++,w++;for(var R=(x-E)*l+1>>>0,A=new Uint8Array(R);E!==x;){for(var U=p[E],S=0,D=R-1;(U!==0||S<_)&&D!==-1;D--,S++)U+=256*A[D]>>>0,A[D]=U%a>>>0,U=U/a>>>0;if(U!==0)throw new Error("Non-zero carry");_=S,E++}for(var m=R-_;m!==R&&A[m]===0;)m++;for(var B=c.repeat(w);m<R;++m)B+=r.charAt(A[m]);return B}function y(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var w=0;if(p[w]!==" "){for(var _=0,E=0;p[w]===c;)_++,w++;for(var x=(p.length-w)*d+1>>>0,R=new Uint8Array(x);p[w];){var A=t[p.charCodeAt(w)];if(A===255)return;for(var U=0,S=x-1;(A!==0||U<E)&&S!==-1;S--,U++)A+=a*R[S]>>>0,R[S]=A%256>>>0,A=A/256>>>0;if(A!==0)throw new Error("Non-zero carry");E=U,w++}if(p[w]!==" "){for(var D=x-E;D!==x&&R[D]===0;)D++;for(var m=new Uint8Array(_+(x-D)),B=_;D!==x;)m[B++]=R[D++];return m}}}function h(p){var w=y(p);if(w)return w;throw new Error(`Non-${e} character`)}return{encode:u,decodeUnsafe:y,decode:h}}var ur=lr,fr=ur;class pr{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class hr{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const o=t.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return St(this,e)}}class gr{decoders;constructor(e){this.decoders=e}or(e){return St(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function St(r,e){return new gr({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class yr{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,o){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=o,this.encoder=new pr(e,t,n),this.decoder=new hr(e,t,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Ct({name:r,prefix:e,encode:t,decode:n}){return new yr(r,e,t,n)}function we({name:r,prefix:e,alphabet:t}){const{encode:n,decode:o}=fr(t,r);return Ct({prefix:e,name:r,encode:n,decode:i=>ke(o(i))})}function wr(r,e,t,n){let o=r.length;for(;r[o-1]==="=";)--o;const i=new Uint8Array(o*t/8|0);let s=0,a=0,c=0;for(let d=0;d<o;++d){const l=e[r[d]];if(l===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|l,s+=t,s>=8&&(s-=8,i[c++]=255&a>>s)}if(s>=t||(255&a<<8-s)!==0)throw new SyntaxError("Unexpected end of data");return i}function mr(r,e,t){const n=e[e.length-1]==="=",o=(1<<t)-1;let i="",s=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],s+=8;s>t;)s-=t,i+=e[o&a>>s];if(s!==0&&(i+=e[o&a<<t-s]),n)for(;(i.length*t&7)!==0;)i+="=";return i}function vr(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function H({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const o=vr(n);return Ct({prefix:e,name:r,encode(i){return mr(i,n,t)},decode(i){return wr(i,o,t,r)}})}const ae=H({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});H({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});H({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});H({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});H({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});H({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});H({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});H({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});H({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const Ie=we({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"});we({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});const G=we({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});we({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Sr=bt,tt=128,Cr=-128,br=Math.pow(2,31);function bt(r,e,t){e=e||[],t=t||0;for(var n=t;r>=br;)e[t++]=r&255|tt,r/=128;for(;r&Cr;)e[t++]=r&255|tt,r>>>=7;return e[t]=r|0,bt.bytes=t-n+1,e}var Pr=Ne,Ar=128,rt=127;function Ne(r,n){var t=0,n=n||0,o=0,i=n,s,a=r.length;do{if(i>=a)throw Ne.bytes=0,new RangeError("Could not decode varint");s=r[i++],t+=o<28?(s&rt)<<o:(s&rt)*Math.pow(2,o),o+=7}while(s>=Ar);return Ne.bytes=i-n,t}var Ir=Math.pow(2,7),_r=Math.pow(2,14),Tr=Math.pow(2,21),Er=Math.pow(2,28),xr=Math.pow(2,35),Dr=Math.pow(2,42),Nr=Math.pow(2,49),Rr=Math.pow(2,56),Ur=Math.pow(2,63),Mr=function(r){return r<Ir?1:r<_r?2:r<Tr?3:r<Er?4:r<xr?5:r<Dr?6:r<Nr?7:r<Rr?8:r<Ur?9:10},Br={encode:Sr,decode:Pr,encodingLength:Mr},fe=Br;function K(r,e=0){return[fe.decode(r,e),fe.decode.bytes]}function ee(r,e,t=0){return fe.encode(r,e,t),e}function Z(r){return fe.encodingLength(r)}function Pt(r,e){const t=e.byteLength,n=Z(r),o=n+Z(t),i=new Uint8Array(o+t);return ee(r,i,0),ee(t,i,n),i.set(e,o),new $e(r,t,e,i)}function kr(r){const e=ke(r),[t,n]=K(e),[o,i]=K(e.subarray(n)),s=e.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new $e(t,o,s,e)}function $r(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&dr(r.bytes,t.bytes)}}let $e=class{code;size;digest;bytes;constructor(e,t,n,o){this.code=e,this.size=t,this.digest=n,this.bytes=o}};function nt(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return Fr(t,Re(r),e??G.encoder);default:return Lr(t,Re(r),e??ae.encoder)}}const ot=new WeakMap;function Re(r){const e=ot.get(r);if(e==null){const t=new Map;return ot.set(r,t),t}return e}class I{code;version;multihash;bytes;"/";constructor(e,t,n,o){this.code=t,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==oe)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==zr)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return I.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=Pt(e,t);return I.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return I.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&$r(e.multihash,n.multihash)}toString(e){return nt(this,e)}toJSON(){return{"/":nt(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof I)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:o,multihash:i,bytes:s}=t;return new I(n,o,i,s??it(n,o,i.bytes))}else if(t[Vr]===!0){const{version:n,multihash:o,code:i}=t,s=kr(o);return I.create(n,i,s)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==oe)throw new Error(`Version 0 CID must use dag-pb (code: ${oe}) block encoding`);return new I(e,t,n,n.bytes)}case 1:{const o=it(e,t,n.bytes);return new I(e,t,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return I.create(0,oe,e)}static createV1(e,t){return I.create(1,e,t)}static decode(e){const[t,n]=I.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=I.inspectBytes(e),n=t.size-t.multihashSize,o=ke(e.subarray(n,n+t.multihashSize));if(o.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=o.subarray(t.multihashSize-t.digestSize),s=new $e(t.multihashCode,t.digestSize,i,o);return[t.version===0?I.createV0(s):I.createV1(t.codec,s),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[u,y]=K(e.subarray(t));return t+=y,u};let o=n(),i=oe;if(o===18?(o=0,t=0):i=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const s=t,a=n(),c=n(),d=t+c,l=d-s;return{version:o,codec:i,multihashCode:a,digestSize:c,multihashSize:l,size:d}}static parse(e,t){const[n,o]=Or(e,t),i=I.decode(o);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Re(i).set(n,e),i}}function Or(r,e){switch(r[0]){case"Q":{const t=e??G;return[G.prefix,t.decode(`${G.prefix}${r}`)]}case G.prefix:{const t=e??G;return[G.prefix,t.decode(r)]}case ae.prefix:{const t=e??ae;return[ae.prefix,t.decode(r)]}case Ie.prefix:{const t=e??Ie;return[Ie.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Fr(r,e,t){const{prefix:n}=t;if(n!==G.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const o=e.get(n);if(o==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return o}function Lr(r,e,t){const{prefix:n}=t,o=e.get(n);if(o==null){const i=t.encode(r);return e.set(n,i),i}else return o}const oe=112,zr=18;function it(r,e,t){const n=Z(r),o=n+Z(e),i=new Uint8Array(o+t.byteLength);return ee(r,i,0),ee(e,i,n),i.set(t,o),i}const Vr=Symbol.for("@ipld/js-cid/CID"),At=8,me=4;BigInt(me);const ve=254,Se=256,J=me*ve/At,Oe=me*Se/At,Ue=BigInt(J),st=BigInt(Oe),Me=ve/Se,C=Oe/me,Hr=BigInt(C),jr=2*C+1,Wr=r=>{if(r instanceof Uint8Array){if(r.length>C)return r.subarray(0,C);if(r.length==C)return r}const e=new Uint8Array(C);return e.set([...r]),e},at=()=>It,It=Wr(new Uint8Array(C).fill(0));Object.freeze(It.buffer);function qr(r,...e){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(r.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`)}function ct(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Gr(r,e){qr(r);const t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yr=r=>r instanceof Uint8Array,_e=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),z=(r,e)=>r<<32-e|r>>>e,Kr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Kr)throw new Error("Non little-endian hardware is not supported");function Zr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function _t(r){if(typeof r=="string"&&(r=Zr(r)),!Yr(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}class Xr{clone(){return this._cloneInto()}}function Jr(r){const e=n=>r().update(_t(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Qr(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(t>>o&i),a=Number(t&i),c=n?4:0,d=n?0:4;r.setUint32(e+c,s,n),r.setUint32(e+d,a,n)}class en extends Xr{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=_e(this.buffer)}update(e){ct(this);const{view:t,buffer:n,blockLen:o}=this;e=_t(e);const i=e.length;for(let s=0;s<i;){const a=Math.min(o-this.pos,i-s);if(a===o){const c=_e(e);for(;o<=i-s;s+=o)this.process(c,s);continue}n.set(e.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ct(this),Gr(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:o,isLE:i}=this;let{pos:s}=this;t[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(n,0),s=0);for(let u=s;u<o;u++)t[u]=0;Qr(n,o-8,BigInt(this.length*8),i),this.process(n,0);const a=_e(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=c/4,l=this.get();if(d>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<d;u++)a.setUint32(4*u,l[u],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:o,finished:i,destroyed:s,pos:a}=this;return e.length=o,e.pos=a,e.finished=i,e.destroyed=s,o%t&&e.buffer.set(n),e}}const tn=(r,e,t)=>r&e^~r&t,rn=(r,e,t)=>r&e^r&t^e&t,nn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),j=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),W=new Uint32Array(64);let on=class extends en{constructor(){super(64,32,8,!1),this.A=j[0]|0,this.B=j[1]|0,this.C=j[2]|0,this.D=j[3]|0,this.E=j[4]|0,this.F=j[5]|0,this.G=j[6]|0,this.H=j[7]|0}get(){const{A:e,B:t,C:n,D:o,E:i,F:s,G:a,H:c}=this;return[e,t,n,o,i,s,a,c]}set(e,t,n,o,i,s,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)W[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){const y=W[u-15],h=W[u-2],p=z(y,7)^z(y,18)^y>>>3,w=z(h,17)^z(h,19)^h>>>10;W[u]=w+W[u-7]+p+W[u-16]|0}let{A:n,B:o,C:i,D:s,E:a,F:c,G:d,H:l}=this;for(let u=0;u<64;u++){const y=z(a,6)^z(a,11)^z(a,25),h=l+y+tn(a,c,d)+nn[u]+W[u]|0,w=(z(n,2)^z(n,13)^z(n,22))+rn(n,o,i)|0;l=d,d=c,c=a,a=s+h|0,s=i,i=o,o=n,n=h+w|0}n=n+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,d=d+this.G|0,l=l+this.H|0,this.set(n,o,i,s,a,c,d,l)}roundClean(){W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sn=Jr(()=>new on),Fe="sha2-256",Le=18,te=32,Te=new Uint8Array([18,32]);let an=class{constructor(e){this.code=Le,this.name=Fe,this.bytes=e,this.size=te,this.digest=e.subarray(2)}};const Tt=r=>{const e=new Uint8Array(Te.length+te);return e.set(Te,0),e.set(sn(r),Te.length),new an(e)},cn=Object.freeze(Object.defineProperty({__proto__:null,code:Le,digest:Tt,name:Fe,size:te},Symbol.toStringTag,{value:"Module"})),dn=Le,ln=Object.freeze(Object.defineProperty({__proto__:null,code:dn,digest:Tt,name:Fe,size:te},Symbol.toStringTag,{value:"Module"})),un=["string","number","bigint","symbol"],fn=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function pn(r){if(r===null)return"null";if(r===void 0)return"undefined";if(r===!0||r===!1)return"boolean";const e=typeof r;if(un.includes(e))return e;if(e==="function")return"Function";if(Array.isArray(r))return"Array";if(hn(r))return"Buffer";const t=gn(r);return t||"Object"}function hn(r){return r&&r.constructor&&r.constructor.isBuffer&&r.constructor.isBuffer.call(null,r)}function gn(r){const e=Object.prototype.toString.call(r).slice(8,-1);if(fn.includes(e))return e}class f{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}f.uint=new f(0,"uint",!0);f.negint=new f(1,"negint",!0);f.bytes=new f(2,"bytes",!0);f.string=new f(3,"string",!0);f.array=new f(4,"array",!1);f.map=new f(5,"map",!1);f.tag=new f(6,"tag",!1);f.float=new f(7,"float",!0);f.false=new f(7,"false",!0);f.true=new f(7,"true",!0);f.null=new f(7,"null",!0);f.undefined=new f(7,"undefined",!0);f.break=new f(7,"break",!0);class b{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Et=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function";new TextDecoder;const yn=new TextEncoder;function dt(r){return Et&&globalThis.Buffer.isBuffer(r)}const wn=Et?r=>r.length>64?globalThis.Buffer.from(r):lt(r):r=>r.length>64?yn.encode(r):lt(r);function mn(r,e){if(dt(r)&&dt(e))return r.compare(e);for(let t=0;t<r.length;t++)if(r[t]!==e[t])return r[t]<e[t]?-1:1;return 0}function lt(r){const e=[];let t=0;for(let n=0;n<r.length;n++){let o=r.charCodeAt(n);o<128?e[t++]=o:o<2048?(e[t++]=o>>6|192,e[t++]=o&63|128):(o&64512)===55296&&n+1<r.length&&(r.charCodeAt(n+1)&64512)===56320?(o=65536+((o&1023)<<10)+(r.charCodeAt(++n)&1023),e[t++]=o>>18|240,e[t++]=o>>12&63|128,e[t++]=o>>6&63|128,e[t++]=o&63|128):(e[t++]=o>>12|224,e[t++]=o>>6&63|128,e[t++]=o&63|128)}return e}const Ce="CBOR decode error:",xt="CBOR encode error:",$=[24,256,65536,4294967296,BigInt("18446744073709551616")];function re(r,e){return F(r,0,e.value)}function F(r,e,t){if(t<$[0]){const n=Number(t);r.push([e|n])}else if(t<$[1]){const n=Number(t);r.push([e|24,n])}else if(t<$[2]){const n=Number(t);r.push([e|25,n>>>8,n&255])}else if(t<$[3]){const n=Number(t);r.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(t);if(n<$[4]){const o=[e|27,0,0,0,0,0,0,0];let i=Number(n&BigInt(4294967295)),s=Number(n>>BigInt(32)&BigInt(4294967295));o[8]=i&255,i=i>>8,o[7]=i&255,i=i>>8,o[6]=i&255,i=i>>8,o[5]=i&255,o[4]=s&255,s=s>>8,o[3]=s&255,s=s>>8,o[2]=s&255,s=s>>8,o[1]=s&255,r.push(o)}else throw new Error(`${Ce} encountered BigInt larger than allowable range`)}}re.encodedSize=function(e){return F.encodedSize(e.value)};F.encodedSize=function(e){return e<$[0]?1:e<$[1]?2:e<$[2]?3:e<$[3]?5:9};re.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const Dt=BigInt(-1),Nt=BigInt(1);function ze(r,e){const t=e.value,n=typeof t=="bigint"?t*Dt-Nt:t*-1-1;F(r,e.type.majorEncoded,n)}ze.encodedSize=function(e){const t=e.value,n=typeof t=="bigint"?t*Dt-Nt:t*-1-1;return n<$[0]?1:n<$[1]?2:n<$[2]?3:n<$[3]?5:9};ze.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0};function pe(r){return r.encodedBytes===void 0&&(r.encodedBytes=r.type===f.string?wn(r.value):r.value),r.encodedBytes}function be(r,e){const t=pe(e);F(r,e.type.majorEncoded,t.length),r.push(t)}be.encodedSize=function(e){const t=pe(e);return F.encodedSize(t.length)+t.length};be.compareTokens=function(e,t){return vn(pe(e),pe(t))};function vn(r,e){return r.length<e.length?-1:r.length>e.length?1:mn(r,e)}const Sn=be;function Ve(r,e){F(r,f.array.majorEncoded,e.value)}Ve.compareTokens=re.compareTokens;Ve.encodedSize=function(e){return F.encodedSize(e.value)};function He(r,e){F(r,f.map.majorEncoded,e.value)}He.compareTokens=re.compareTokens;He.encodedSize=function(e){return F.encodedSize(e.value)};function je(r,e){F(r,f.tag.majorEncoded,e.value)}je.compareTokens=re.compareTokens;je.encodedSize=function(e){return F.encodedSize(e.value)};const Cn=20,bn=21,Pn=22,An=23;function We(r,e,t){const n=e.value;if(n===!1)r.push([f.float.majorEncoded|Cn]);else if(n===!0)r.push([f.float.majorEncoded|bn]);else if(n===null)r.push([f.float.majorEncoded|Pn]);else if(n===void 0)r.push([f.float.majorEncoded|An]);else{let o,i=!1;(!t||t.float64!==!0)&&(Ut(n),o=Mt(L,1),n===o||Number.isNaN(n)?(L[0]=249,r.push(L.slice(0,3)),i=!0):(Bt(n),o=kt(L,1),n===o&&(L[0]=250,r.push(L.slice(0,5)),i=!0))),i||(In(n),o=_n(L,1),L[0]=251,r.push(L.slice(0,9)))}}We.encodedSize=function(e,t){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!t||t.float64!==!0){Ut(n);let o=Mt(L,1);if(n===o||Number.isNaN(n))return 3;if(Bt(n),o=kt(L,1),n===o)return 5}return 9};const Rt=new ArrayBuffer(9),O=new DataView(Rt,1),L=new Uint8Array(Rt,0);function Ut(r){if(r===1/0)O.setUint16(0,31744,!1);else if(r===-1/0)O.setUint16(0,64512,!1);else if(Number.isNaN(r))O.setUint16(0,32256,!1);else{O.setFloat32(0,r);const e=O.getUint32(0),t=(e&2139095040)>>23,n=e&8388607;if(t===255)O.setUint16(0,31744,!1);else if(t===0)O.setUint16(0,(r&2147483648)>>16|n>>13,!1);else{const o=t-127;o<-24?O.setUint16(0,0):o<-14?O.setUint16(0,(e&2147483648)>>16|1<<24+o,!1):O.setUint16(0,(e&2147483648)>>16|o+15<<10|n>>13,!1)}}}function Mt(r,e){if(r.length-e<2)throw new Error(`${Ce} not enough data for float16`);const t=(r[e]<<8)+r[e+1];if(t===31744)return 1/0;if(t===64512)return-1/0;if(t===32256)return NaN;const n=t>>10&31,o=t&1023;let i;return n===0?i=o*2**-24:n!==31?i=(o+1024)*2**(n-25):i=o===0?1/0:NaN,t&32768?-i:i}function Bt(r){O.setFloat32(0,r,!1)}function kt(r,e){if(r.length-e<4)throw new Error(`${Ce} not enough data for float32`);const t=(r.byteOffset||0)+e;return new DataView(r.buffer,t,4).getFloat32(0,!1)}function In(r){O.setFloat64(0,r,!1)}function _n(r,e){if(r.length-e<8)throw new Error(`${Ce} not enough data for float64`);const t=(r.byteOffset||0)+e;return new DataView(r.buffer,t,8).getFloat64(0,!1)}We.compareTokens=re.compareTokens;function Tn(){const r=[];return r[f.uint.major]=re,r[f.negint.major]=ze,r[f.bytes.major]=be,r[f.string.major]=Sn,r[f.array.major]=Ve,r[f.map.major]=He,r[f.tag.major]=je,r[f.float.major]=We,r}Tn();class he{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do if(t.obj===e)return!0;while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${xt} object contains circular references`);return new he(t,e)}}const q={null:new b(f.null,null),undefined:new b(f.undefined,void 0),true:new b(f.true,!0),false:new b(f.false,!1),emptyArray:new b(f.array,0),emptyMap:new b(f.map,0)},X={number(r,e,t,n){return!Number.isInteger(r)||!Number.isSafeInteger(r)?new b(f.float,r):r>=0?new b(f.uint,r):new b(f.negint,r)},bigint(r,e,t,n){return r>=BigInt(0)?new b(f.uint,r):new b(f.negint,r)},Uint8Array(r,e,t,n){return new b(f.bytes,r)},string(r,e,t,n){return new b(f.string,r)},boolean(r,e,t,n){return r?q.true:q.false},null(r,e,t,n){return q.null},undefined(r,e,t,n){return q.undefined},ArrayBuffer(r,e,t,n){return new b(f.bytes,new Uint8Array(r))},DataView(r,e,t,n){return new b(f.bytes,new Uint8Array(r.buffer,r.byteOffset,r.byteLength))},Array(r,e,t,n){if(!r.length)return t.addBreakTokens===!0?[q.emptyArray,new b(f.break)]:q.emptyArray;n=he.createCheck(n,r);const o=[];let i=0;for(const s of r)o[i++]=Ee(s,t,n);return t.addBreakTokens?[new b(f.array,r.length),o,new b(f.break)]:[new b(f.array,r.length),o]},Object(r,e,t,n){const o=e!=="Object",i=o?r.keys():Object.keys(r),s=o?r.size:i.length;if(!s)return t.addBreakTokens===!0?[q.emptyMap,new b(f.break)]:q.emptyMap;n=he.createCheck(n,r);const a=[];let c=0;for(const d of i)a[c++]=[Ee(d,t,n),Ee(o?r.get(d):r[d],t,n)];return En(a,t),t.addBreakTokens?[new b(f.map,s),a,new b(f.break)]:[new b(f.map,s),a]}};X.Map=X.Object;X.Buffer=X.Uint8Array;for(const r of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))X[`${r}Array`]=X.DataView;function Ee(r,e={},t){const n=pn(r),o=e&&e.typeEncoders&&e.typeEncoders[n]||X[n];if(typeof o=="function"){const s=o(r,n,e,t);if(s!=null)return s}const i=X[n];if(!i)throw new Error(`${xt} unsupported type: ${n}`);return i(r,n,e,t)}function En(r,e){e.mapSorter&&r.sort(e.mapSorter)}const $t=42;function xn(r){if(r.asCID!==r&&r["/"]!==r.bytes)return null;const e=I.asCID(r);if(!e)return null;const t=new Uint8Array(e.bytes.byteLength+1);return t.set(e.bytes,1),[new b(f.tag,$t),new b(f.bytes,t)]}function Dn(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function Nn(r){if(Number.isNaN(r))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(r===1/0||r===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const Rn={typeEncoders:{Object:xn,undefined:Dn,number:Nn}};({...Rn.typeEncoders});function Un(r){if(r[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return I.decode(r.subarray(1))}const Ot={tags:[]};Ot.tags[$t]=Un;Ot.tags.slice();function Mn(r,e={}){const t=e.hasher||ln,{digest:n}=t.digest(r);return Bn(n)}const Ft=(r,e,t)=>{const n=new Uint8Array(r.length+e.length);return n.set(r,0),n.set(e,r.length),Mn(n,t)};function Bn(r){return r[C-1]&=63,r}const kn=r=>{let e=0n;for(;r>>=1n;)e++;return Number(e)},Lt=r=>r<=1n?0:kn(BigInt(r)-1n)+1,$n=r=>{let e=0;const t=1n;for(let n=0n;n<64n;n++)(r&t<<n)!==0n&&e++;return e},On=r=>1n<<r,Fn=r=>Ln(r)-r,Ln=r=>zn(r)*Ue,zn=r=>{const e=(r+Ue-1n)/Ue;return 2n**BigInt(Lt(e))},Vn=r=>{const e=BigInt(r);return e<st?{error:RangeError(`Minimum piece size is ${st} bytes`)}:$n(e)!==1?{error:RangeError("Piece size must be a power of 2")}:{ok:e}},Hn=r=>{const e=Vn(r);if(e.error)throw e.error;return e.ok},qe=r=>jn(2n**BigInt(r)),jn=r=>r*Hr,Wn="fr32-sha2-256-trunc254-padded-binary-tree",ce=4113,qn=9,ge=1,zt=te,ut=qn+ge+te,Ge=Z(ce),Gn=Ge+Z(ut)+ut,Yn=255;qe(Yn)*BigInt(ve)/BigInt(Se);const Kn=r=>new Qn(r),Zn=({digest:r})=>{const[,e]=K(r);return r[e]},Xn=({digest:r})=>{const[e]=K(r);return BigInt(e)},Jn=({digest:r})=>{const[,e]=K(r);return r.subarray(e+ge,e+ge+te)};class Qn{constructor(e){this.bytes=e;const[t]=K(e);if(t!==ce)throw new RangeError(`Expected multihash with code ${ce}`);let n=Ge;const[o,i]=K(e,n);n+=i;const s=e.subarray(n);if(s.length!==o)throw new RangeError(`Invalid multihash size expected ${n+o} bytes, got ${e.length} bytes`);this.digest=s}get name(){return Wn}get code(){return ce}get size(){return this.digest.length}get padding(){return Xn(this)}get height(){return Zn(this)}get root(){return Jn(this)}}const Be=64;class eo{constructor(){this.bytes=new Uint8Array(Be*C),this.bytes.set(at(),0),this.node=at(),this.length=C}slice(e,t){for(;this.length<t;)this.node=Ft(this.node,this.node),this.bytes.set(this.node,this.length),this.length+=C;return this.bytes.subarray(e,t)}}const to=new eo,ro=r=>{if(r<0||r>=Be)throw new Error(`Only levels between 0 and ${Be-1} inclusive are available`);return to.slice(C*r,C*(r+1))},xe=r=>{const e=r.length/C,t=new Array(e);for(let n=0;n<e;n++){const o=n*C,i=r.subarray(o,o+C);t[n]=i}return t};function Vt(r){const e=Math.max(r,jr),t=Math.floor(Math.log2(e)),n=Math.ceil(Me*2**(t+1));return e<=n?n:Math.ceil(Me*2**(t+2))}const Ht=r=>Vt(r)/Me,De=(r,e=new Uint8Array(Ht(r.length)))=>{const n=Vt(r.byteLength)/J;for(let o=0;o<n;o++){const i=o*J,s=o*Oe;e.set(r.subarray(i,i+32),s),e[s+31]&=63;for(let a=32;a<64;a++)e[s+a]=r[i+a]<<2|r[i+a-1]>>6;e[s+63]&=63;for(let a=64;a<96;a++)e[s+a]=r[i+a]<<4|r[i+a-1]>>4;e[s+95]&=63;for(let a=96;a<127;a++)e[s+a]=r[i+a]<<6|r[i+a-1]>>2;e[s+127]=r[i+126]>>2}return e},no="fr32-sha2-256-trunc254-padded-binary-tree",ft=4113,oo=255,pt=qe(oo)*BigInt(ve)/BigInt(Se),jt=()=>new io;class io{constructor(){this.bytesWritten=0n,this.buffer=new Uint8Array(J),this.offset=0,this.layers=[[]]}count(){return this.bytesWritten}digest(){const e=new Uint8Array(Gn),t=this.digestInto(e,0,!0);return Kn(e.subarray(0,t))}digestInto(e,t=0,n=!0){const{buffer:o,layers:i,offset:s,bytesWritten:a}=this;let[c,...d]=i;(s>0||a===0n)&&(c=[...c,...xe(De(o.fill(0,s)))]);const l=ao([c,...d]),u=l.length-1,[y]=l[u],h=Number(Fn(this.bytesWritten)),p=Z(h);let w=t;if(n){ee(ft,e,w),w+=Ge;const _=p+ge+zt,E=Z(_);ee(_,e,w),w+=E}return ee(h,e,w),w+=p,e[w]=u,w+=1,e.set(y,w),w+=y.length,w-t}write(e){const{buffer:t,offset:n,layers:o}=this,i=o[0],{length:s}=e;if(s===0)return this;if(this.bytesWritten+BigInt(s)>pt)throw new RangeError(`Writing ${s} bytes exceeds max payload size of ${pt}`);if(n+s<t.length)return t.set(e,n),this.offset+=s,this.bytesWritten+=BigInt(s),this;{const a=t.length-n;t.set(e.subarray(0,a),n),i.push(...xe(De(t)));let c=a;for(;c+J<s;){const d=e.subarray(c,c+J);i.push(...xe(De(d))),c+=J}return this.buffer.set(e.subarray(c),0),this.offset=s-c,this.bytesWritten+=BigInt(s),so(this.layers),this}}reset(){return this.offset=0,this.bytesWritten=0n,this.layers.length=1,this.layers[0].length=0,this}dispose(){this.reset()}get code(){return ft}get name(){return no}}const so=r=>Wt(r,!1),ao=r=>Wt([...r],!0),Wt=(r,e)=>{let t=0;for(;t<r.length;){let n=r[t+1];const o=r[t];e&&o.length%2>0&&n&&o.push(ro(t)),t+=1,n=n?e?[...n]:n:[];let i=0;for(;i+1<o.length;){const s=Ft(o[i],o[i+1]);delete o[i],delete o[i+1],n.push(s),i+=2}n.length&&(r[t]=n),o.splice(0,i)}return r},co=60,lo=8,uo=1<<lo;BigInt(uo);const de=16,Y=64/8,qt=(r,e)=>Ye(r,e).subarray(C+Y+Y),Gt=(r,e)=>({...r,checksum:qt(r,e)}),Yt=({node:r,location:e})=>({root:r,offset:Kt(e)*BigInt(C),size:On(BigInt(e.level))*BigInt(C)}),fo=r=>{const e=Lt(r.size/BigInt(C));return{node:r.root,location:{level:e,index:r.offset/BigInt(C)>>BigInt(e)}}},po=(r,e)=>Gt(Yt(r),e),Kt=({index:r,level:e})=>r<<BigInt(e),ho=r=>Ye(r).subarray(C),Ye=({root:r,size:e,offset:t,checksum:n},o={})=>{const i=new Uint8Array(C+Y+Y+de);i.set(r,0);const s=new DataView(i.buffer);if(s.setBigUint64(C,BigInt(t),!0),s.setBigUint64(C+Y,BigInt(e),!0),!n){const a=o.hasher||cn,{digest:c}=a.digest(i);n=c.subarray(0,de),n[de-1]&=63}return i.set(n,C+Y+Y),i},go=r=>r.offset%128n!==0n?{error:Error("offset is not aligned in padded data")}:{ok:r},yo=Object.freeze(Object.defineProperty({__proto__:null,ChecksumSize:de,Uint64Size:Y,computeChecksum:qt,fromSource:Yt,fromSourceWithChecksum:po,toBytes:Ye,toIndexNode:ho,toLeafIndex:Kt,toSource:fo,validate:go,withChecksum:Gt},Symbol.toStringTag,{value:"Module"})),{Uint64Size:ht,ChecksumSize:wo}=yo;BigInt(C+ht+ht+wo);BigInt(C);qe(co);Hn(2n**35n);const Ke=61697,Ze=4114;function mo(r){return Ht(r)}function vo(r){try{const e=I.parse(r);return e.code!==Ke||e.multihash.code!==Ze?null:e}catch{return null}}function So(r){return r.code===Ke&&r.multihash.code===Ze}function V(r){return typeof r=="string"?vo(r):typeof r=="object"&&I.asCID(r)!==null&&So(r)?r:null}function Zt(r){const e=Pt(Ze,r.bytes.subarray(r.bytes.length-zt));return I.create(1,Ke,e)}function Co(r){const e=jt(),t=2048;for(let o=0;o<r.length;o+=t)e.write(r.subarray(o,o+t));const n=e.digest();return Zt(n)}function bo(){const r=jt();let e=!1,t=null;return{stream:new TransformStream({transform(o,i){r.write(o),i.enqueue(o)},flush(){const o=r.digest();t=Zt(o),e=!0}}),getCommP:()=>e?t:null}}async function Xt(r,e){const t=V(e);if(t==null)throw new Error(`Invalid CommP: ${String(e)}`);if(!r.ok)throw new Error(`Download failed: ${r.status} ${r.statusText}`);if(r.body==null)throw new Error("Response body is null");const{stream:n,getCommP:o}=bo(),i=[],s=new TransformStream({transform(h,p){i.push(h),p.enqueue(h)}}),c=r.body.pipeThrough(n).pipeThrough(s).getReader();try{for(;;){const{done:h}=await c.read();if(h)break}}finally{c.releaseLock()}const d=o();if(d==null)throw new Error("Failed to calculate CommP from stream");if(d.toString()!==t.toString())throw new Error(`CommP verification failed. Expected: ${String(t)}, Got: ${String(d)}`);const l=i.reduce((h,p)=>h+p.length,0),u=new Uint8Array(l);let y=0;for(const h of i)u.set(h,y),y+=h.length;return u}function g(r,e,t,n){const o=`${r} ${e} failed: ${t}`;return n!=null?new Error(o,{cause:n}):new Error(o)}const P={USDFC:"USDFC",FIL:"FIL"},ie={mainnet:314,calibration:314159},ye={ERC20:["function balanceOf(address owner) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function approve(address spender, uint256 amount) returns (bool)","function allowance(address owner, address spender) view returns (uint256)","function transfer(address to, uint256 amount) returns (bool)"],PAYMENTS:["function deposit(address token, address to, uint256 amount)","function withdraw(address token, uint256 amount)","function accounts(address token, address owner) view returns (uint256 funds, uint256 lockupCurrent, uint256 lockupRate, uint256 lockupLastSettledAt)","function setOperatorApproval(address token, address operator, bool approved, uint256 rateAllowance, uint256 lockupAllowance)","function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 rateUsed, uint256 lockupAllowance, uint256 lockupUsed)"],PANDORA_SERVICE:["function registerServiceProvider(string pdpUrl, string pieceRetrievalUrl) external","function approveServiceProvider(address provider) external","function rejectServiceProvider(address provider) external","function removeServiceProvider(uint256 providerId) external","function addServiceProvider(address provider, string pdpUrl, string pieceRetrievalUrl) external","function isProviderApproved(address provider) external view returns (bool)","function getProviderIdByAddress(address provider) external view returns (uint256)","function getApprovedProvider(uint256 providerId) external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt))","function pendingProviders(address provider) external view returns (string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt)","function approvedProviders(uint256 providerId) external view returns (address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)","function nextServiceProviderId() external view returns (uint256)","function owner() external view returns (address)","function getServicePrice() external view returns (tuple(uint256 pricePerTiBPerMonthNoCDN, uint256 pricePerTiBPerMonthWithCDN, address tokenAddress, uint256 epochsPerMonth) pricing)","function approvedProvidersMap(address) external view returns (bool)","function providerToId(address) external view returns (uint256)","function getAllApprovedProviders() external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)[])","function getClientProofSets(address client) external view returns (tuple(uint256 railId, address payer, address payee, uint256 commissionBps, string metadata, string[] rootMetadata, uint256 clientDataSetId, bool withCDN)[])","function clientDataSetIDs(address client) external view returns (uint256)","function railToProofSet(uint256 railId) external view returns (uint256 proofSetId)","function getProofSet(uint256 id) public view returns (tuple(uint256 railId, address payer, address payee, uint256 commissionBps, string metadata, string[] rootMetadata, uint256 clientDataSetId, bool withCDN) info)"],PDP_VERIFIER:["function getNextRootId(uint256 setId) public view returns (uint256)","function proofSetLive(uint256 setId) public view returns (bool)","function getProofSetLeafCount(uint256 setId) public view returns (uint256)","function getProofSetOwner(uint256 setId) public view returns (address, address)","function getProofSetListener(uint256 setId) public view returns (address)","event ProofSetCreated(uint256 indexed setId, address indexed owner)"]},se={EPOCHS_PER_DAY:2880n,DEFAULT_LOCKUP_DAYS:10n},ne={TiB:1024n*1024n*1024n*1024n,MAX_UPLOAD_SIZE:200*1024*1024,MIN_UPLOAD_SIZE:65},N={TRANSACTION_PROPAGATION_TIMEOUT_MS:3e4,TRANSACTION_PROPAGATION_POLL_INTERVAL_MS:2e3,PROOF_SET_CREATION_TIMEOUT_MS:7*60*1e3,PROOF_SET_CREATION_POLL_INTERVAL_MS:2e3,PIECE_PARKING_TIMEOUT_MS:7*60*1e3,PIECE_PARKING_POLL_INTERVAL_MS:5e3,TRANSACTION_CONFIRMATIONS:1,ROOT_ADDITION_TIMEOUT_MS:7*60*1e3,ROOT_ADDITION_POLL_INTERVAL_MS:1e3},k={USDFC:{mainnet:"0x80B98d3aa09ffff255c3ba4A241111Ff1262F045",calibration:"0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0"},PAYMENTS:{mainnet:"",calibration:"0x0E690D3e60B0576D01352AB03b258115eb84A047"},PANDORA_SERVICE:{mainnet:"",calibration:"0xf49ba5eaCdFD5EE3744efEdf413791935FE4D4c5"},PDP_VERIFIER:{mainnet:"",calibration:"0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC"}},Jt={SHA2_256_TRUNC254_PADDED:"sha2-256-trunc254-padded"};function Qt(r,e){return`${r.replace(/\/$/,"")}/piece/${e.toString()}`}function er(r,e,t=0){const n=r.replace(/\/$/,""),o=e.multihash.digest,i=vt(o),s=new URLSearchParams({name:Jt.SHA2_256_TRUNC254_PADDED,hash:i,size:t.toString()});return`${n}/pdp/piece?${s.toString()}`}function Po(r){if(typeof r!="object"||r==null)return!1;const e=r;return!(typeof e.createMessageHash!="string"||typeof e.proofsetCreated!="boolean"||typeof e.service!="string"||typeof e.txStatus!="string"||e.ok!==null&&typeof e.ok!="boolean"||e.proofSetId!==void 0&&typeof e.proofSetId!="number")}function Ao(r){if(typeof r!="object"||r==null)return!1;const e=r;if(typeof e.txHash!="string"||typeof e.txStatus!="string"||typeof e.proofSetId!="number"||typeof e.rootCount!="number"||e.addMessageOk!==null&&typeof e.addMessageOk!="boolean")return!1;if(e.confirmedRootIds!==void 0){if(!Array.isArray(e.confirmedRootIds))return!1;for(const t of e.confirmedRootIds)if(typeof t!="number")return!1}return!0}function Io(r){if(typeof r!="object"||r==null)return!1;const e=r,t=typeof e.pieceCid=="string",n=typeof e.piece_cid=="string";if(!t&&!n)return!1;const o=e.pieceCid??e.piece_cid;return V(o)!=null}function _o(r){if(!Po(r))throw new Error("Invalid proof set creation status response format");return r}function To(r){if(!Ao(r))throw new Error("Invalid root addition status response format");return r}function Eo(r){if(!Io(r)){if(typeof r=="object"&&r!=null){const o=r,i=o.pieceCid??o.piece_cid;if(i!=null&&V(i)==null)throw new Error("Invalid find piece response: pieceCid is not a valid CommP")}throw new Error("Invalid find piece response format")}const e=r,t=e.pieceCid??e.piece_cid,n=V(t);if(n==null)throw new Error("Invalid find piece response: pieceCid is not a valid CommP");return{pieceCid:n,piece_cid:e.piece_cid}}class gt{_apiEndpoint;_retrievalEndpoint;_authHelper;_serviceName;constructor(e,t,n,o="public"){if(t.trim()==="")throw new Error("PDP API endpoint is required");if(n.trim()==="")throw new Error("PDP retrieval endpoint is required");this._apiEndpoint=t.replace(/\/$/,""),this._retrievalEndpoint=n.replace(/\/$/,""),this._authHelper=e,this._serviceName=o}async createProofSet(e,t,n,o){const i=await this._authHelper.signCreateProofSet(e,t,n),s=this._encodeProofSetCreateData({metadata:"",payer:await this._authHelper.getSignerAddress(),withCDN:n,signature:i.signature}),a={recordKeeper:o,extraData:`0x${s}`},c=await fetch(`${this._apiEndpoint}/pdp/proof-sets`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});if(c.status!==201){const y=await c.text();throw new Error(`Failed to create proof set: ${c.status} ${c.statusText} - ${y}`)}const d=c.headers.get("Location");if(d==null)throw new Error("Server did not provide Location header in response");const l=d.match(/\/pdp\/proof-sets\/created\/(.+)$/);if(l==null)throw new Error(`Invalid Location header format: ${d}`);return{txHash:l[1],statusUrl:`${this._apiEndpoint}${d}`}}async addRoots(e,t,n,o){if(o.length===0)throw new Error("At least one root must be provided");for(const h of o)if(V(h.cid)==null)throw new Error(`Invalid CommP: ${String(h.cid)}`);const i=await this._authHelper.signAddRoots(t,n,o),s=this._encodeAddRootsExtraData({signature:i.signature,metadata:""}),a={roots:o.map(h=>{const p=typeof h.cid=="string"?h.cid:h.cid.toString();return{rootCid:p,subroots:[{subrootCid:p}]}}),extraData:`0x${s}`},c=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}/roots`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});if(c.status!==201){const h=await c.text();throw new Error(`Failed to add roots to proof set: ${c.status} ${c.statusText} - ${h}`)}const d=c.headers.get("Location");let l,u;if(d!=null){const h=d.match(/\/roots\/added\/([0-9a-fA-Fx]+)$/);h!=null&&(l=h[1],l.startsWith("0x")||(l="0x"+l),u=`${this._apiEndpoint}${d}`)}const y=await c.text();return{message:y!==""?y:`Roots added to proof set ID ${e} successfully`,txHash:l,statusUrl:u}}async getProofSetCreationStatus(e){const t=await fetch(`${this._apiEndpoint}/pdp/proof-sets/created/${e}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(t.status===404)throw new Error(`Proof set creation not found for transaction hash: ${e}`);if(t.status!==200){const o=await t.text();throw new Error(`Failed to get proof set creation status: ${t.status} ${t.statusText} - ${o}`)}const n=await t.json();return _o(n)}async getRootAdditionStatus(e,t){const n=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}/roots/added/${t}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(n.status===404)throw new Error(`Root addition not found for transaction: ${t}`);if(n.status!==200){const i=await n.text();throw new Error(`Failed to get root addition status: ${n.status} ${n.statusText} - ${i}`)}const o=await n.json();return To(o)}async findPiece(e,t){const n=V(e);if(n==null)throw new Error(`Invalid CommP: ${String(e)}`);const o=er(this._apiEndpoint,n,t),i=await fetch(o,{method:"GET",headers:{}});if(i.status===404)throw new Error(`Piece not found: ${n.toString()}`);if(!i.ok){const a=await i.text();throw new Error(`Failed to find piece: ${i.status} ${i.statusText} - ${a}`)}const s=await i.json();return Eo(s)}async uploadPiece(e){const t=e instanceof ArrayBuffer?new Uint8Array(e):e,n=await Co(t),o=t.length,i=n.multihash.digest,s=vt(i),c={check:{name:Jt.SHA2_256_TRUNC254_PADDED,hash:s,size:o}},d=await fetch(`${this._apiEndpoint}/pdp/piece`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});if(d.status===200)return{commP:n,size:o};if(d.status!==201){const p=await d.text();throw new Error(`Failed to create upload session: ${d.status} ${d.statusText} - ${p}`)}const l=d.headers.get("Location");if(l==null)throw new Error("Server did not provide Location header in response (may be restricted by CORS policy)");const u=l.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);if(u==null)throw new Error(`Invalid Location header format: ${l}`);const y=u[1],h=await fetch(`${this._apiEndpoint}/pdp/piece/upload/${y}`,{method:"PUT",headers:{"Content-Type":"application/octet-stream","Content-Length":t.length.toString()},body:t});if(h.status!==204){const p=await h.text();throw new Error(`Failed to upload piece: ${h.status} ${h.statusText} - ${p}`)}return{commP:n,size:o}}async downloadPiece(e){const t=V(e);if(t==null)throw new Error(`Invalid CommP: ${String(e)}`);const n=Qt(this._retrievalEndpoint,t),o=await fetch(n);return await Xt(o,t)}_encodeProofSetCreateData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return v.ethers.AbiCoder.defaultAbiCoder().encode(["string","address","bool","bytes"],[e.metadata,e.payer,e.withCDN,t]).slice(2)}_encodeAddRootsExtraData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return v.ethers.AbiCoder.defaultAbiCoder().encode(["bytes","string"],[t,e.metadata]).slice(2)}async ping(){const e=await fetch(`${this._apiEndpoint}/ping`,{method:"GET",headers:{}});if(e.status!==200){const t=await e.text().catch(()=>"Unknown error");throw new Error(`Provider ping failed: ${e.status} ${e.statusText} - ${t}`)}}getApiEndpoint(){return this._apiEndpoint}getAuthHelper(){return this._authHelper}}const T={CreateProofSet:[{name:"clientDataSetId",type:"uint256"},{name:"withCDN",type:"bool"},{name:"payee",type:"address"}],Cid:[{name:"data",type:"bytes"}],RootData:[{name:"root",type:"Cid"},{name:"rawSize",type:"uint256"}],AddRoots:[{name:"clientDataSetId",type:"uint256"},{name:"firstAdded",type:"uint256"},{name:"rootData",type:"RootData[]"}],ScheduleRemovals:[{name:"clientDataSetId",type:"uint256"},{name:"rootIds",type:"uint256[]"}],DeleteProofSet:[{name:"clientDataSetId",type:"uint256"}]};class yt{signer;domain;constructor(e,t,n){this.signer=t,this.domain={name:"PandoraService",version:"1",chainId:Number(n),verifyingContract:e}}getUnderlyingSigner(){return"signer"in this.signer&&this.signer.constructor.name==="NonceManager"?this.signer.signer:this.signer}async isMetaMaskSigner(){try{const e=this.getUnderlyingSigner();if(e.constructor.name==="Wallet")return!1;const t=e.provider;if(t==null)return!1;if("_eip1193Provider"in t||typeof globalThis<"u"&&"window"in globalThis&&globalThis.window?.ethereum!=null||"send"in t||"request"in t)return!0}catch{}return!1}async signWithMetaMask(e,t){const n=this.signer.provider;if(n==null)throw new Error("No provider available");const o=await this.signer.getAddress();let i="";for(const d of Object.keys(e))if(d!=="Cid"&&d!=="RootData"){i=d;break}const s={types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...e},primaryType:i,domain:this.domain,message:t};let a;"_eip1193Provider"in n?a=n._eip1193Provider:("request"in n,a=n);let c;return a!=null&&"request"in a?c=await a.request({method:"eth_signTypedData_v4",params:[o.toLowerCase(),JSON.stringify(s)]}):c=await n.send("eth_signTypedData_v4",[o.toLowerCase(),JSON.stringify(s)]),c}async signCreateProofSet(e,t,n=!1){let o;if(await this.isMetaMaskSigner()){const c={clientDataSetId:e.toString(),withCDN:n,payee:t};o=await this.signWithMetaMask({CreateProofSet:T.CreateProofSet},c)}else{const c={clientDataSetId:BigInt(e),withCDN:n,payee:t};o=await this.getUnderlyingSigner().signTypedData(this.domain,{CreateProofSet:T.CreateProofSet},c)}const s=v.ethers.Signature.from(o),a=v.ethers.TypedDataEncoder.hash(this.domain,{CreateProofSet:T.CreateProofSet},{clientDataSetId:BigInt(e),withCDN:n,payee:t});return{signature:o,v:s.v,r:s.r,s:s.s,signedData:a}}async signAddRoots(e,t,n){const o=[];for(const d of n){const l=typeof d.cid=="string"?V(d.cid):d.cid;if(l==null)throw new Error(`Invalid CommP: ${String(d.cid)}`);o.push({root:{data:l.bytes},rawSize:BigInt(mo(d.rawSize))})}let i;if(await this.isMetaMaskSigner()){const d={clientDataSetId:e.toString(),firstAdded:t.toString(),rootData:o.map(u=>({root:{data:v.ethers.hexlify(u.root.data)},rawSize:u.rawSize.toString()}))},l={AddRoots:T.AddRoots,RootData:T.RootData,Cid:T.Cid};i=await this.signWithMetaMask(l,d)}else{const d={clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:o},l={AddRoots:T.AddRoots,RootData:T.RootData,Cid:T.Cid};i=await this.getUnderlyingSigner().signTypedData(this.domain,l,d)}const a=v.ethers.Signature.from(i),c=v.ethers.TypedDataEncoder.hash(this.domain,{AddRoots:T.AddRoots,RootData:T.RootData,Cid:T.Cid},{clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:o});return{signature:i,v:a.v,r:a.r,s:a.s,signedData:c}}async signScheduleRemovals(e,t){const n=t.map(c=>BigInt(c));let o;if(await this.isMetaMaskSigner()){const c={clientDataSetId:e.toString(),rootIds:n.map(d=>d.toString())};o=await this.signWithMetaMask({ScheduleRemovals:T.ScheduleRemovals},c)}else{const c={clientDataSetId:BigInt(e),rootIds:n};o=await this.getUnderlyingSigner().signTypedData(this.domain,{ScheduleRemovals:T.ScheduleRemovals},c)}const s=v.ethers.Signature.from(o),a=v.ethers.TypedDataEncoder.hash(this.domain,{ScheduleRemovals:T.ScheduleRemovals},{clientDataSetId:BigInt(e),rootIds:n});return{signature:o,v:s.v,r:s.r,s:s.s,signedData:a}}async signDeleteProofSet(e){let t;if(await this.isMetaMaskSigner()){const s={clientDataSetId:e.toString()};t=await this.signWithMetaMask({DeleteProofSet:T.DeleteProofSet},s)}else{const s={clientDataSetId:BigInt(e)};t=await this.getUnderlyingSigner().signTypedData(this.domain,{DeleteProofSet:T.DeleteProofSet},s)}const o=v.ethers.Signature.from(t),i=v.ethers.TypedDataEncoder.hash(this.domain,{DeleteProofSet:T.DeleteProofSet},{clientDataSetId:BigInt(e)});return{signature:t,v:o.v,r:o.r,s:o.s,signedData:i}}async getSignerAddress(){return await this.signer.getAddress()}}class M{_synapse;_provider;_pdpServer;_pandoraService;_pandoraAddress;_withCDN;_proofSetId;_signer;proofSetId;storageProvider;static validateRawSize(e,t){if(e<ne.MIN_UPLOAD_SIZE)throw g("StorageService",t,`Data size (${e} bytes) is below minimum allowed size (${ne.MIN_UPLOAD_SIZE} bytes).`);if(e>ne.MAX_UPLOAD_SIZE)throw g("StorageService",t,`Data size (${e} bytes) exceeds maximum allowed size (${ne.MAX_UPLOAD_SIZE} bytes)`)}constructor(e,t,n,o,i){this._synapse=e,this._provider=n,this._proofSetId=o,this._withCDN=i.withCDN??!1,this._signer=e.getSigner(),this._pandoraService=t,this.proofSetId=o.toString(),this.storageProvider=n.owner,this._pandoraAddress=e.getPandoraAddress();const s=new yt(this._pandoraAddress,this._signer,e.getChainId());this._pdpServer=new gt(s,n.pdpUrl,n.pieceRetrievalUrl)}static async create(e,t,n){const i=await e.getSigner().getAddress(),s=await M.resolveProviderAndProofSet(e,t,i,n);try{n.callbacks?.onProviderSelected?.(s.provider)}catch(c){console.error("Error in onProviderSelected callback:",c)}let a;if(s.proofSetId===-1)a=await M.createProofSet(e,t,s.provider,n.withCDN??!1,n.callbacks);else{a=s.proofSetId;try{n.callbacks?.onProofSetResolved?.({isExisting:!0,proofSetId:a,provider:s.provider})}catch(c){console.error("Error in onProofSetResolved callback:",c)}}return new M(e,t,s.provider,a,n)}static async createProofSet(e,t,n,o,i){const s=e.getSigner(),a=await s.getAddress(),c=await t.getNextClientDataSetId(a),d=e.getPandoraAddress(),l=new yt(d,s,e.getChainId()),u=new gt(l,n.pdpUrl,n.pieceRetrievalUrl),y=await u.createProofSet(c,n.owner,o,d),{txHash:h,statusUrl:p}=y,w=e.getProvider();let _=null;const E=Date.now(),x=N.TRANSACTION_PROPAGATION_TIMEOUT_MS,R=N.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;for(;Date.now()-E<x;){try{if(_=await w.getTransaction(h),_!==null)break}catch(S){console.warn(`Failed to fetch transaction ${h}, retrying...`,S)}await new Promise(S=>setTimeout(S,R))}if(_===null)throw g("StorageService","create",`Transaction ${h} not found after ${x/1e3} seconds. The transaction may not have propagated to the RPC node.`);try{i?.onProofSetCreationStarted?.(_,p)}catch(S){console.error("Error in onProofSetCreationStarted callback:",S)}let A;try{A=await t.waitForProofSetCreationWithStatus(_,u,N.PROOF_SET_CREATION_TIMEOUT_MS,N.PROOF_SET_CREATION_POLL_INTERVAL_MS,async(S,D)=>{if(i?.onProofSetCreationProgress!=null)try{let m;if(S.chainStatus.transactionMined&&S.chainStatus.blockNumber!=null)try{m=await _.wait(N.TRANSACTION_CONFIRMATIONS)??void 0}catch(B){console.error("Failed to fetch transaction receipt:",B)}i.onProofSetCreationProgress({transactionMined:S.chainStatus.transactionMined,transactionSuccess:S.chainStatus.transactionSuccess,proofSetLive:S.chainStatus.proofSetLive,serverConfirmed:S.serverStatus?.ok===!0,proofSetId:S.summary.proofSetId??void 0,elapsedMs:D,receipt:m})}catch(m){console.error("Error in onProofSetCreationProgress callback:",m)}})}catch(S){throw g("StorageService","waitForProofSetCreation",S instanceof Error?S.message:"Proof set creation failed")}if(!A.summary.isComplete||A.summary.proofSetId==null)throw g("StorageService","waitForProofSetCreation",`Proof set creation failed: ${A.summary.error??"Transaction may have failed"}`);const U=A.summary.proofSetId;try{i?.onProofSetResolved?.({isExisting:!1,proofSetId:U,provider:n})}catch(S){console.error("Error in onProofSetResolved callback:",S)}return U}static async resolveProviderAndProofSet(e,t,n,o){return o.proofSetId!=null?await M.resolveByProofSetId(o.proofSetId,t,n,o):o.providerId!=null?await M.resolveByProviderId(o.providerId,t,n,o.withCDN??!1):o.providerAddress!=null?await M.resolveByProviderAddress(o.providerAddress,t,n,o.withCDN??!1):await M.smartSelectProvider(t,n,o.withCDN??!1,e.getSigner())}static async resolveByProofSetId(e,t,n,o){const s=(await t.getClientProofSetsWithDetails(n)).find(d=>d.pdpVerifierProofSetId===e);if(s==null||!s.isLive||!s.isManaged)throw g("StorageService","resolveByProofSetId",`Proof set ${e} not found, not owned by ${n}, or not managed by the current Pandora contract`);(o.providerId!=null||o.providerAddress!=null)&&await M.validateProofSetConsistency(s,o,t);const a=await t.getProviderIdByAddress(s.payee);if(a===0)throw g("StorageService","resolveByProofSetId",`Provider ${s.payee} for proof set ${e} is not currently approved`);return{provider:await t.getApprovedProvider(a),proofSetId:e,isExisting:!0}}static async validateProofSetConsistency(e,t,n){if(t.providerId!=null){const o=await n.getProviderIdByAddress(e.payee);if(o!==t.providerId)throw g("StorageService","validateProofSetConsistency",`Proof set ${e.pdpVerifierProofSetId} belongs to provider ID ${o}, but provider ID ${t.providerId} was requested`)}if(t.providerAddress!=null&&e.payee.toLowerCase()!==t.providerAddress.toLowerCase())throw g("StorageService","validateProofSetConsistency",`Proof set ${e.pdpVerifierProofSetId} belongs to provider ${e.payee}, but provider ${t.providerAddress} was requested`)}static async resolveByProviderId(e,t,n,o){const[i,s]=await Promise.all([t.getApprovedProvider(e),t.getClientProofSetsWithDetails(n)]);if(i.owner==="0x0000000000000000000000000000000000000000")throw g("StorageService","resolveByProviderId",`Provider ID ${e} not found or not approved`);const a=s.filter(c=>c.payee.toLowerCase()===i.owner.toLowerCase()&&c.isLive&&c.isManaged&&c.withCDN===o);if(a.length>0){const c=a.sort((d,l)=>d.currentRootCount>0&&l.currentRootCount===0?-1:l.currentRootCount>0&&d.currentRootCount===0?1:d.pdpVerifierProofSetId-l.pdpVerifierProofSetId);return{provider:i,proofSetId:c[0].pdpVerifierProofSetId,isExisting:!0}}return{provider:i,proofSetId:-1,isExisting:!1}}static async resolveByProviderAddress(e,t,n,o){const i=await t.getProviderIdByAddress(e);if(i===0)throw g("StorageService","resolveByProviderAddress",`Provider ${e} is not currently approved`);return await M.resolveByProviderId(i,t,n,o)}static async smartSelectProvider(e,t,n,o){const s=(await e.getClientProofSetsWithDetails(t)).filter(d=>d.isLive&&d.isManaged&&d.withCDN===n);if(s.length>0){const l=s.sort((h,p)=>h.currentRootCount>0&&p.currentRootCount===0?-1:p.currentRootCount>0&&h.currentRootCount===0?1:h.pdpVerifierProofSetId-p.pdpVerifierProofSetId)[0],u=await e.getProviderIdByAddress(l.payee);if(u===0)throw g("StorageService","smartSelectProvider",`Provider ${l.payee} for proof set ${l.pdpVerifierProofSetId} is not currently approved`);return{provider:await e.getApprovedProvider(u),proofSetId:l.pdpVerifierProofSetId,isExisting:!0}}const a=await e.getAllApprovedProviders();if(a.length===0)throw g("StorageService","smartSelectProvider","No approved storage providers available");return{provider:await M.selectRandomProvider(a,o),proofSetId:-1,isExisting:!1}}static async selectRandomProvider(e,t){let n;if(typeof globalThis.crypto<"u"&&globalThis.crypto.getRandomValues!=null){const o=new Uint8Array(1);globalThis.crypto.getRandomValues(o),n=o[0]%e.length}else{const o=Date.now(),i=Math.random(),a=(await t.getAddress()).split("").reduce((d,l)=>d+l.charCodeAt(0),0),c=o*i*a%e.length;n=Math.floor(Math.abs(c))}return e[n]}async preflightUpload(e){M.validateRawSize(e,"preflightUpload");const t=await this._pandoraService.checkAllowanceForStorage(e,this._withCDN,this._synapse.payments);return{estimatedCost:{perEpoch:t.costs.perEpoch,perDay:t.costs.perDay,perMonth:t.costs.perMonth},allowanceCheck:{sufficient:t.sufficient,message:t.message},selectedProvider:this._provider,selectedProofSetId:this._proofSetId}}async upload(e,t){const n=e instanceof ArrayBuffer?new Uint8Array(e):e,o=n.length;M.validateRawSize(o,"upload");let i;try{i=await this._pdpServer.uploadPiece(n)}catch(l){throw g("StorageService","uploadPiece","Failed to upload piece to storage provider",l)}const s=N.PIECE_PARKING_TIMEOUT_MS,a=N.PIECE_PARKING_POLL_INTERVAL_MS,c=Date.now();let d=!1;for(;Date.now()-c<s;)try{await this._pdpServer.findPiece(i.commP,i.size),d=!0;break}catch{Date.now()-c+a<s&&await new Promise(l=>setTimeout(l,a))}if(!d)throw g("StorageService","findPiece","Timeout waiting for piece to be parked on storage provider");t?.onUploadComplete!=null&&t.onUploadComplete(i.commP);try{const l=await this._pandoraService.getAddRootsInfo(this._proofSetId),u=[{cid:i.commP,rawSize:i.size}],y=await this._pdpServer.addRoots(this._proofSetId,l.clientDataSetId,l.nextRootId,u);let h=l.nextRootId;if(y.txHash!=null){let p=null;const w=Date.now(),_=N.TRANSACTION_PROPAGATION_TIMEOUT_MS,E=N.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;for(;Date.now()-w<_;){try{if(p=await this._synapse.getProvider().getTransaction(y.txHash),p!==null)break}catch{}await new Promise(m=>setTimeout(m,E))}if(p==null)throw g("StorageService","addRoots",`Server returned transaction hash ${y.txHash} but transaction was not found on-chain after ${_/1e3} seconds`);t?.onRootAdded?.(p);let x;try{x=await p.wait(N.TRANSACTION_CONFIRMATIONS)}catch(m){throw g("StorageService","addRoots","Failed to wait for transaction confirmation",m)}if(x?.status!==1)throw g("StorageService","addRoots","Root addition transaction failed on-chain");const R=N.ROOT_ADDITION_TIMEOUT_MS,A=N.ROOT_ADDITION_POLL_INTERVAL_MS,U=Date.now();let S=null,D=!1;for(;Date.now()-U<R;)try{const m=await this._pdpServer.getRootAdditionStatus(this._proofSetId,y.txHash);if(m.txStatus==="pending"){await new Promise(B=>setTimeout(B,A));continue}if(m.addMessageOk===!1)throw new Error("Root addition failed: Transaction was unsuccessful");if(m.confirmedRootIds!=null&&m.confirmedRootIds.length>0){h=m.confirmedRootIds[0],t?.onRootConfirmed?.(m.confirmedRootIds),D=!0;break}await new Promise(B=>setTimeout(B,A))}catch(m){if(S=m,m instanceof Error&&m.message.includes("not found")){await new Promise(B=>setTimeout(B,A));continue}throw g("StorageService","addRoots",`Failed to verify root addition with server: ${m instanceof Error?m.message:"Unknown error"}`,m)}if(!D){const m=`Failed to verify root addition after ${R/1e3} seconds: ${S!=null?S.message:"Server did not provide confirmation"}`;throw g("StorageService","addRoots",m+". The transaction was confirmed on-chain but the server failed to acknowledge it.",S)}}else t?.onRootAdded?.();return{commp:i.commP,size:i.size,rootId:h}}catch(l){throw g("StorageService","addRoots","Failed to add root to proof set",l)}}async providerDownload(e,t){return await this._synapse.download(e,{providerAddress:this._provider.owner,withCDN:this._withCDN})}async download(e,t){return await this.providerDownload(e,t)}}class xo{_provider;_signer;_network;_disableNonceManager;_usdfcContract=null;_paymentsContract=null;constructor(e,t,n,o){this._provider=e,this._signer=t,this._network=n,this._disableNonceManager=o}_getUsdfcContract(){if(this._usdfcContract==null){const e=k.USDFC[this._network];if(e==null)throw new Error(`USDFC contract not deployed on ${this._network} network`);this._usdfcContract=new v.ethers.Contract(e,ye.ERC20,this._signer)}return this._usdfcContract}_getPaymentsContract(){if(this._paymentsContract==null){const e=k.PAYMENTS[this._network];if(e==null||e==="")throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);this._paymentsContract=new v.ethers.Contract(e,ye.PAYMENTS,this._signer)}return this._paymentsContract}async balance(e=P.USDFC){if(e!==P.USDFC)throw g("PaymentsService","payments contract balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);return(await this.accountInfo(e)).availableFunds}async accountInfo(e=P.USDFC){if(e!==P.USDFC)throw g("PaymentsService","account info",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const t=await this._signer.getAddress(),n=k.USDFC[this._network],o=this._getPaymentsContract();let i;try{i=await o.accounts(n,t)}catch(p){throw g("PaymentsService","account info","Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.",p)}const[s,a,c,d]=i,u=await this.getCurrentEpoch()-BigInt(d),y=BigInt(a)+BigInt(c)*u,h=BigInt(s)-y;return{funds:BigInt(s),lockupCurrent:BigInt(a),lockupRate:BigInt(c),lockupLastSettledAt:BigInt(d),availableFunds:h>0n?h:0n}}async getCurrentEpoch(){const e=await this._provider.getBlock("latest");if(e==null)throw g("PaymentsService","getCurrentEpoch","Failed to get latest block");return BigInt(e.number)}async walletBalance(e){if(e==null||e===P.FIL)try{const t=await this._signer.getAddress();return await this._provider.getBalance(t)}catch(t){throw g("PaymentsService","wallet FIL balance check","Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.",t)}if(e===P.USDFC)try{const t=await this._signer.getAddress();return await this._getUsdfcContract().balanceOf(t)}catch(t){throw g("PaymentsService","wallet USDFC balance check","Unexpected error while checking USDFC token balance in wallet.",t)}throw g("PaymentsService","wallet balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for balance queries.`)}decimals(e=P.USDFC){return 18}async allowance(e,t){if(e!==P.USDFC)throw g("PaymentsService","allowance",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),o=this._getUsdfcContract();try{return await o.allowance(n,t)}catch(i){throw g("PaymentsService","allowance check","Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.",i)}}async approve(e,t,n){if(e!==P.USDFC)throw g("PaymentsService","approve",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const o=typeof n=="bigint"?n:BigInt(n);if(o<0n)throw g("PaymentsService","approve","Approval amount cannot be negative");const i=await this._signer.getAddress(),s=this._getUsdfcContract(),a={};if(this._disableNonceManager){const c=await this._provider.getTransactionCount(i,"pending");a.nonce=c}try{return await s.approve(t,o,a)}catch(c){throw g("PaymentsService","approve",`Failed to approve ${t} to spend ${o.toString()} ${e}`,c)}}async approveService(e,t,n,o=P.USDFC){if(o!==P.USDFC)throw g("PaymentsService","approveService",`Token "${o}" is not supported. Currently only USDFC token is supported.`);const i=typeof t=="bigint"?t:BigInt(t),s=typeof n=="bigint"?n:BigInt(n);if(i<0n||s<0n)throw g("PaymentsService","approveService","Allowance values cannot be negative");const a=await this._signer.getAddress(),c=k.USDFC[this._network],d=this._getPaymentsContract(),l={};if(this._disableNonceManager){const u=await this._provider.getTransactionCount(a,"pending");l.nonce=u}try{return await d.setOperatorApproval(c,e,!0,i,s,l)}catch(u){throw g("PaymentsService","approveService",`Failed to approve service ${e} as operator for ${o}`,u)}}async revokeService(e,t=P.USDFC){if(t!==P.USDFC)throw g("PaymentsService","revokeService",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),o=k.USDFC[this._network],i=this._getPaymentsContract(),s={};if(this._disableNonceManager){const a=await this._provider.getTransactionCount(n,"pending");s.nonce=a}try{return await i.setOperatorApproval(o,e,!1,0n,0n,s)}catch(a){throw g("PaymentsService","revokeService",`Failed to revoke service ${e} as operator for ${t}`,a)}}async serviceApproval(e,t=P.USDFC){if(t!==P.USDFC)throw g("PaymentsService","serviceApproval",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const n=await this._signer.getAddress(),o=k.USDFC[this._network],i=this._getPaymentsContract();try{const s=await i.operatorApprovals(o,n,e);return{isApproved:s[0],rateAllowance:s[1],lockupAllowance:s[2],rateUsed:s[3],lockupUsed:s[4]}}catch(s){throw g("PaymentsService","serviceApproval",`Failed to check service approval status for ${e}`,s)}}async deposit(e,t=P.USDFC,n){if(t!==P.USDFC)throw g("PaymentsService","deposit",`Unsupported token: ${t}`);const o=typeof e=="bigint"?e:BigInt(e);if(o<=0n)throw g("PaymentsService","deposit","Invalid amount");const i=await this._signer.getAddress(),s=k.USDFC[this._network],a=this._getUsdfcContract(),c=this._getPaymentsContract(),d=await a.balanceOf(i);if(d<o)throw g("PaymentsService","deposit",`Insufficient USDFC: have ${BigInt(d).toString()}, need ${o.toString()}`);const l=k.PAYMENTS[this._network];if(l==null)throw g("PaymentsService","deposit",`Payments contract not deployed on ${this._network}`);const u=await this.allowance(t,l);if(n?.onAllowanceCheck?.(u,o),u<o){const p=await this.approve(t,l,o);n?.onApprovalTransaction?.(p);const w=await p.wait(N.TRANSACTION_CONFIRMATIONS);w!=null&&n?.onApprovalConfirmed?.(w)}n?.onDepositStarting?.();const y={};if(this._disableNonceManager){const p=await this._provider.getTransactionCount(i,"pending");y.nonce=p}return await c.deposit(s,i,o,y)}async withdraw(e,t=P.USDFC){if(t!==P.USDFC)throw g("PaymentsService","withdraw",`Unsupported token: ${t}`);const n=typeof e=="bigint"?e:BigInt(e);if(n<=0n)throw g("PaymentsService","withdraw","Invalid amount");const o=await this._signer.getAddress(),i=k.USDFC[this._network],s=this._getPaymentsContract(),a=await this.accountInfo(t);if(a.availableFunds<n)throw g("PaymentsService","withdraw",`Insufficient available balance: have ${a.availableFunds.toString()}, need ${n.toString()}`);const c={};if(this._disableNonceManager){const l=await this._provider.getTransactionCount(o,"pending");c.nonce=l}return await s.withdraw(i,n,c)}}class Do{_provider;_contract=null;_chainId=null;constructor(e){this._provider=e}async _getContract(){if(this._contract==null){const e=await this._provider.getNetwork();this._chainId=Number(e.chainId);let t;if(this._chainId===314)t=k.PDP_VERIFIER.mainnet;else if(this._chainId===314159)t=k.PDP_VERIFIER.calibration;else throw new Error(`Unsupported network: ${this._chainId}. Only Filecoin mainnet (314) and calibration (314159) are supported.`);this._contract=new v.ethers.Contract(t,ye.PDP_VERIFIER,this._provider)}return this._contract}async proofSetLive(e){return await(await this._getContract()).proofSetLive(e)}async getNextRootId(e){const n=await(await this._getContract()).getNextRootId(e);return Number(n)}async getProofSetListener(e){return await(await this._getContract()).getProofSetListener(e)}async getProofSetOwner(e){const t=await this._getContract(),[n,o]=await t.getProofSetOwner(e);return{owner:n,proposedOwner:o}}async getProofSetLeafCount(e){const n=await(await this._getContract()).getProofSetLeafCount(e);return Number(n)}async extractProofSetIdFromReceipt(e){try{const t=await this._getContract();for(const n of e.logs)try{const o=t.interface.parseLog({topics:n.topics,data:n.data});if(o!=null&&o.name==="ProofSetCreated")return Number(o.args.setId)}catch{continue}return null}catch(t){throw new Error(`Failed to extract proof set ID from receipt: ${t instanceof Error?t.message:String(t)}`)}}async getContractAddress(){return(await this._getContract()).target}}class No{_provider;_pandoraAddress;_pandoraContract=null;_pdpVerifier=null;constructor(e,t){this._provider=e,this._pandoraAddress=t}_getPandoraContract(){return this._pandoraContract==null&&(this._pandoraContract=new v.ethers.Contract(this._pandoraAddress,ye.PANDORA_SERVICE,this._provider)),this._pandoraContract}_getPDPVerifier(){return this._pdpVerifier==null&&(this._pdpVerifier=new Do(this._provider)),this._pdpVerifier}async getClientProofSets(e){const t=this._getPandoraContract();try{const n=await t.getClientProofSets(e),o=[];for(let i=0;i<n.length;i++){const s=n[i];s.payer==="0x0000000000000000000000000000000000000000"||Number(s.railId)===0||o.push({railId:Number(s.railId),payer:s.payer,payee:s.payee,commissionBps:Number(s.commissionBps),metadata:s.metadata,rootMetadata:s.rootMetadata,clientDataSetId:Number(s.clientDataSetId),withCDN:s.withCDN})}return o}catch(n){throw new Error(`Failed to get client proof sets: ${n instanceof Error?n.message:String(n)}`)}}async getClientProofSetsWithDetails(e,t=!1){const n=await this.getClientProofSets(e),o=this._getPDPVerifier(),i=this._getPandoraContract(),s=n.map(async c=>{try{const d=await i.railToProofSet(c.railId);if(Number(d)===0)return t?null:{...c,pdpVerifierProofSetId:0,nextRootId:0,currentRootCount:0,isLive:!1,isManaged:!1};const[l,u]=await Promise.all([o.proofSetLive(Number(d)),o.getProofSetListener(Number(d)).catch(()=>null)]),y=u!=null&&u.toLowerCase()===this._pandoraAddress.toLowerCase();if(t&&!y)return null;const h=l?await o.getNextRootId(Number(d)):0;return{...c,pdpVerifierProofSetId:Number(d),nextRootId:Number(h),currentRootCount:Number(h),isLive:l,isManaged:y}}catch(d){throw new Error(`Failed to get details for proof set with rail ID ${c.railId}: ${d instanceof Error?d.message:String(d)}`)}});return(await Promise.all(s)).filter(c=>c!==null)}async getAddRootsInfo(e){try{const t=this._getPandoraContract(),n=this._getPDPVerifier(),[o,i,s,a]=await Promise.all([n.proofSetLive(Number(e)),n.getNextRootId(Number(e)),n.getProofSetListener(Number(e)),t.getProofSet(Number(e))]);if(!o)throw new Error(`Proof set ${e} does not exist or is not live`);if(s.toLowerCase()!==this._pandoraAddress.toLowerCase())throw new Error(`Proof set ${e} is not managed by this Pandora contract (${this._pandoraAddress}), managed by ${String(s)}`);const c=Number(a.clientDataSetId);return{nextRootId:Number(i),clientDataSetId:c,currentRootCount:Number(i)}}catch(t){throw new Error(`Failed to get add roots info: ${t instanceof Error?t.message:String(t)}`)}}async getNextClientDataSetId(e){try{const n=await this._getPandoraContract().clientDataSetIDs(e);return Number(n)}catch(t){throw new Error(`Failed to get next client dataset ID: ${t instanceof Error?t.message:String(t)}`)}}async verifyProofSetCreation(e){try{const t=typeof e=="string"?e:e.hash;let n;if(typeof e=="string"?n=await this._provider.getTransactionReceipt(t):n=await e.wait(N.TRANSACTION_CONFIRMATIONS),n==null)return{transactionMined:!1,transactionSuccess:!1,proofSetLive:!1};if(!(n.status===1))return{transactionMined:!0,transactionSuccess:!1,proofSetLive:!1,blockNumber:n.blockNumber,gasUsed:n.gasUsed,error:"Transaction failed"};const i=this._getPDPVerifier(),s=await i.extractProofSetIdFromReceipt(n);if(s==null)return{transactionMined:!0,transactionSuccess:!0,proofSetLive:!1,blockNumber:n.blockNumber,gasUsed:n.gasUsed,error:"Could not find ProofSetCreated event in transaction"};const a=await i.proofSetLive(s);return{transactionMined:!0,transactionSuccess:!0,proofSetId:s,proofSetLive:a,blockNumber:n.blockNumber,gasUsed:n.gasUsed}}catch(t){return{transactionMined:!1,transactionSuccess:!1,proofSetLive:!1,error:`Verification failed: ${t instanceof Error?t.message:String(t)}`}}}async getComprehensiveProofSetStatus(e,t){const n=typeof e=="string"?e:e.hash;let o=null;try{o=await t.getProofSetCreationStatus(n)}catch{}const i=await this.verifyProofSetCreation(e),s={isComplete:i.transactionMined&&i.proofSetLive&&o!=null&&o.ok===!0,isLive:i.proofSetLive,proofSetId:i.proofSetId??o?.proofSetId??null,error:i.error??null};return{txHash:n,serverStatus:o,chainStatus:i,summary:s}}async waitForProofSetCreationWithStatus(e,t,n=N.PROOF_SET_CREATION_TIMEOUT_MS,o=N.PROOF_SET_CREATION_POLL_INTERVAL_MS,i){const s=Date.now();for(;Date.now()-s<n;){const a=await this.getComprehensiveProofSetStatus(e,t);if(i!=null)try{await i(a,Date.now()-s)}catch(c){console.error("Error in progress callback:",c)}if(a.summary.isComplete||a.summary.error!=null)return a;await new Promise(c=>setTimeout(c,o))}throw new Error(`Timeout waiting for proof set creation after ${n}ms`)}async calculateStorageCost(e){const t=this._getPandoraContract();let n,o,i;try{const d=await t.getServicePrice();n=BigInt(d.pricePerTiBPerMonthNoCDN),o=BigInt(d.pricePerTiBPerMonthWithCDN),i=BigInt(d.epochsPerMonth)}catch(d){throw console.error("Error calling getServicePrice:",d),d}const s=BigInt(e),a=n*s/(ne.TiB*i),c=o*s/(ne.TiB*i);return{perEpoch:a,perDay:a*se.EPOCHS_PER_DAY,perMonth:a*i,withCDN:{perEpoch:c,perDay:c*se.EPOCHS_PER_DAY,perMonth:c*i}}}async checkAllowanceForStorage(e,t,n,o){const i=await n.serviceApproval(this._pandoraAddress,P.USDFC),s=await this.calculateStorageCost(e),a=t?s.withCDN:s,c=a.perEpoch,d=BigInt(o??se.DEFAULT_LOCKUP_DAYS)*se.EPOCHS_PER_DAY,l=c*d,u=BigInt(i.rateUsed)+c,y=BigInt(i.lockupUsed)+l,h=i.rateAllowance>=u&&i.lockupAllowance>=y;let p;if(!h){const w=[];i.rateAllowance<u&&w.push(`Rate allowance insufficient: current ${String(i.rateAllowance)}, need ${String(u)}`),i.lockupAllowance<y&&w.push(`Lockup allowance insufficient: current ${String(i.lockupAllowance)}, need ${String(y)}`),p=w.join(". ")}return{rateAllowanceNeeded:u,lockupAllowanceNeeded:y,currentRateAllowance:i.rateAllowance,currentLockupAllowance:i.lockupAllowance,currentRateUsed:i.rateUsed,currentLockupUsed:i.lockupUsed,sufficient:h,message:p,costs:{perEpoch:a.perEpoch,perDay:a.perDay,perMonth:a.perMonth},depositAmountNeeded:l}}async prepareStorageUpload(e,t){const n=await this.calculateStorageCost(e.dataSize),o=e.withCDN===!0?n.withCDN:n,i=await this.checkAllowanceForStorage(e.dataSize,e.withCDN??!1,t),s=[],a=await t.accountInfo(P.USDFC),c=o.perMonth;if(a.availableFunds<c){const d=c-a.availableFunds;s.push({type:"deposit",description:`Deposit ${d} USDFC to payments contract`,execute:async()=>await t.deposit(d,P.USDFC)})}return i.sufficient||s.push({type:"approveService",description:`Approve service with rate allowance ${i.rateAllowanceNeeded} and lockup allowance ${i.lockupAllowanceNeeded}`,execute:async()=>await t.approveService(this._pandoraAddress,i.rateAllowanceNeeded,i.lockupAllowanceNeeded,P.USDFC)}),{estimatedCost:{perEpoch:o.perEpoch,perDay:o.perDay,perMonth:o.perMonth},allowanceCheck:{sufficient:i.sufficient,message:i.message},actions:s}}async registerServiceProvider(e,t,n){return await this._getPandoraContract().connect(e).registerServiceProvider(t,n)}async approveServiceProvider(e,t){return await this._getPandoraContract().connect(e).approveServiceProvider(t)}async rejectServiceProvider(e,t){return await this._getPandoraContract().connect(e).rejectServiceProvider(t)}async removeServiceProvider(e,t){return await this._getPandoraContract().connect(e).removeServiceProvider(t)}async addServiceProvider(e,t,n,o){return await this._getPandoraContract().connect(e).addServiceProvider(t,n,o)}async isProviderApproved(e){return await this._getPandoraContract().isProviderApproved(e)}async getProviderIdByAddress(e){const n=await this._getPandoraContract().getProviderIdByAddress(e);return Number(n)}async getApprovedProvider(e){const n=await this._getPandoraContract().getApprovedProvider(e);return{owner:n.owner,pdpUrl:n.pdpUrl,pieceRetrievalUrl:n.pieceRetrievalUrl,registeredAt:Number(n.registeredAt),approvedAt:Number(n.approvedAt)}}async getPendingProvider(e){const n=await this._getPandoraContract().pendingProviders(e);return{pdpUrl:n.pdpUrl,pieceRetrievalUrl:n.pieceRetrievalUrl,registeredAt:Number(n.registeredAt)}}async getNextProviderId(){const t=await this._getPandoraContract().nextServiceProviderId();return Number(t)}async getOwner(){return await this._getPandoraContract().owner()}async isOwner(e){const t=await e.getAddress(),n=await this.getOwner();return t.toLowerCase()===n.toLowerCase()}async getAllApprovedProviders(){const e=await this.getNextProviderId(),t=[];for(let n=1;n<e;n++)try{const o=await this.getApprovedProvider(n);o.owner!=="0x0000000000000000000000000000000000000000"&&t.push(o)}catch{continue}return t}}class Ro{pandoraService;constructor(e){this.pandoraService=e}async findProviders(e,t){if(t!=null){const a=await this.pandoraService.getProviderIdByAddress(t);if(a===0)throw g("ChainRetriever","findProviders",`Provider ${t} not found or not approved`);return[await this.pandoraService.getApprovedProvider(a)]}const o=(await this.pandoraService.getClientProofSetsWithDetails(e)).filter(a=>a.isLive&&a.currentRootCount>0);if(o.length===0)throw g("ChainRetriever","findProviders",`No active proof sets with data found for client ${e}`);const i=[...new Set(o.map(a=>a.payee))];return await Promise.all(i.map(async a=>{const c=await this.pandoraService.getProviderIdByAddress(a);return await this.pandoraService.getApprovedProvider(c)}))}async fetchFromProviders(e,t,n){const o=[],i=[],s=e.map(async(a,c)=>{const d=new AbortController;i[c]=d,n!=null&&(n.addEventListener("abort",()=>{d.abort(n.reason)},{once:!0}),n.aborted&&d.abort(n.reason));try{const l=er(a.pdpUrl,t),u=await fetch(l,{signal:d.signal});if(!u.ok)throw o.push({provider:a.owner,error:`findPiece returned ${u.status}`}),new Error("Provider does not have piece");const y=Qt(a.pieceRetrievalUrl,t),h=await fetch(y,{signal:d.signal});if(h.ok)return{response:h,index:c};throw o.push({provider:a.owner,error:`download returned ${h.status}`}),new Error(`Download failed with status ${h.status}`)}catch(l){const u=l.message??"Unknown error";throw o.some(y=>y.provider===a.owner)||o.push({provider:a.owner,error:u}),console.warn(`Failed to fetch from provider ${a.owner}:`,u),l}});try{const{response:a,index:c}=await Promise.any(s);return i.forEach((d,l)=>{l!==c&&d.abort()}),a}catch(a){if(a instanceof AggregateError){const c=o.map(d=>`${d.provider}: ${d.error}`).join("; ");throw g("ChainRetriever","fetchFromProviders",`All providers failed to serve piece ${t.toString()}. Details: ${c}`)}throw a}}async fetchPiece(e,t,n){const o=await this.findProviders(t,n?.providerAddress);return await this.fetchFromProviders(o,e,n?.signal)}}class Uo{baseRetriever;network;constructor(e,t){this.baseRetriever=e,this.network=t}hostname(){return this.network==="mainnet"?"filcdn.io":"calibration.filcdn.io"}async fetchPiece(e,t,n){if(n?.withCDN===!0){const o=`https://${t}.${this.hostname()}/${e.toString()}`;try{const i=await fetch(o,{signal:n?.signal});if(i.ok)return i;i.status===402?console.warn("CDN requires payment. Please initialise Synapse SDK with the option `withCDN: true` and re-upload your files."):console.warn("CDN fetch failed with status:",i.status)}catch(i){console.warn("CDN fetch failed:",i)}}return console.log("Falling back to direct retrieval"),await this.baseRetriever.fetchPiece(e,t,n)}}class Xe{_signer;_network;_withCDN;_payments;_provider;_pandoraAddress;_pandoraService;_pieceRetriever;static async create(e){if([e.privateKey,e.provider,e.signer].filter(Boolean).length!==1)throw new Error("Must provide exactly one of: privateKey, provider, or signer");if(e.privateKey!=null&&e.rpcURL==null)throw new Error("rpcURL is required when using privateKey");let n,o;if(e.privateKey!=null&&e.rpcURL!=null){if(e.rpcURL.startsWith("ws://")||e.rpcURL.startsWith("wss://"))n=new v.ethers.WebSocketProvider(e.rpcURL);else if(e.authorization!=null){const l=new v.ethers.FetchRequest(e.rpcURL);l.setHeader("Authorization",e.authorization),n=new v.ethers.JsonRpcProvider(l)}else n=new v.ethers.JsonRpcProvider(e.rpcURL);const d=new v.ethers.Wallet(e.privateKey,n);e.disableNonceManager!==!0?o=new v.ethers.NonceManager(d):o=d}else if(e.provider!=null)if(n=e.provider,"getSigner"in n&&typeof n.getSigner=="function"){const d=await n.getSigner();e.disableNonceManager!==!0?o=new v.ethers.NonceManager(d):o=d}else throw new Error("Provider must support getSigner() method");else if(e.signer!=null){if(o=e.signer,o.provider!=null)n=o.provider;else throw new Error("Signer must have a provider attached");e.disableNonceManager!==!0&&(o=new v.ethers.NonceManager(o))}else throw new Error("Invalid configuration");let i;try{const d=await n.getNetwork(),l=Number(d.chainId);if(l===ie.mainnet)i="mainnet";else if(l===ie.calibration)i="calibration";else throw new Error(`Unsupported network with chain ID ${l}. Synapse SDK only supports Filecoin mainnet (${ie.mainnet}) and calibration (${ie.calibration}) networks.`)}catch(d){throw new Error(`Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. ${d instanceof Error?`Underlying error: ${d.message}`:""}`)}const s=e.pandoraAddress??k.PANDORA_SERVICE[i],a=new No(n,s);let c;if(e.pieceRetriever!=null)c=e.pieceRetriever;else{const d=new Ro(a);c=new Uo(d,i)}return new Xe(n,o,i,e.disableNonceManager===!0,e.withCDN===!0,e.pandoraAddress,a,c)}constructor(e,t,n,o,i,s,a,c){if(this._provider=e,this._signer=t,this._network=n,this._withCDN=i,this._payments=new xo(e,t,n,o),this._pandoraService=a,this._pieceRetriever=c,this._pandoraAddress=s??k.PANDORA_SERVICE[n],this._pandoraAddress===""||this._pandoraAddress===void 0)throw new Error(`No Pandora service address configured for network: ${n}`)}get payments(){return this._payments}getProvider(){return this._provider}getSigner(){return this._signer}getChainId(){return BigInt(ie[this._network])}getPandoraAddress(){return this._pandoraAddress}async createStorage(e){try{const t={...e,withCDN:e?.withCDN??this._withCDN};return await M.create(this,this._pandoraService,t)}catch(t){throw g("Synapse","createStorage","Failed to create storage service",t)}}getNetwork(){return this._network}async download(e,t){const n=V(e);if(n==null)throw g("Synapse","download",`Invalid CommP: ${String(e)}`);const o=await this._signer.getAddress(),i=await this._pieceRetriever.fetchPiece(n,o,{withCDN:t?.withCDN??this._withCDN,providerAddress:t?.providerAddress});return await Xt(i,n)}}const Je="filecoinCalibrationTestnet",Mo=r=>[{chain:Je,contractAddress:r,standardContractType:"ERC721",method:"balanceOf",parameters:[":userAddress"],returnValueTest:{comparator:">",value:"0"}}];async function Bo(r,e,t=void 0){return await r.getSessionSigs({chain:Je,expiration:new Date(Date.now()+6e5).toISOString(),resourceAbilityRequests:[{resource:new Ae.LitAccessControlConditionResource("*"),ability:wt.LIT_ABILITY.AccessControlConditionDecryption}],authNeededCallback:async({uri:o,expiration:i,resourceAbilityRequests:s})=>{const a=await Ae.createSiweMessage({uri:o,expiration:i,resources:s,walletAddress:e.address,nonce:await r.getLatestBlockhash(),litNodeClient:r});return await Ae.generateAuthSig({signer:e,toSign:a})},capacityDelegationAuthSig:t})}async function ko(r,e,t){const n=new nr.LitNodeClientNodeJs({litNetwork:wt.LIT_NETWORK.DatilDev});await n.connect();try{const o=await Bo(n,ue());return await rr.decryptToString({accessControlConditions:Mo(r),chain:Je,ciphertext:e,dataToEncryptHash:t,sessionSigs:o},n)}finally{await n.disconnect()}}class Qe{#e;constructor(e){this.#e=e}static async create(e){const n=await(await Xe.create({signer:new v.ethers.VoidSigner(e,mt()),withCDN:!0,pandoraAddress:"0x55577C413A68CF7Ed1383db3b5122425787162D2"})).createStorage({withCDN:!0});return new Qe(n)}parseCSV(e){return new Promise((t,n)=>{tr.parse(Buffer.from(e),{columns:!0,skip_empty_lines:!1,trim:!0},(o,i)=>o?n(o):t(i))})}async fetchPublicDataset(e){const t=await this.#e.providerDownload(e);return this.parseCSV(t)}async fetchPrivateDataset(e,t,n){const o=await this.#e.providerDownload(t),i=await ko(e,new TextDecoder().decode(o),n);return this.parseCSV(i)}}le.options.cache=!0;class Pe{#e=null;#n=null;#r=null;#t=null;#o=!1;#i=!1;constructor(e){this.#e=e}static async load(e){const t=new Pe(e);return await t.#s(),t}get id(){return this.#e}get price(){return v.ethers.formatUnits(this.#r.toString(),18)}async#s(){const t=await Q.getInstance().getCollectionInfo(this.#e);this.name=t.name,this.description=t.description,this.publicColumns=t.publicColumns,this.privateColumns=t.privateColumns,this.#r=t.price,this.#n=t.owner}async#a(){if(!this.#t){const e=Q.getInstance(),t=await Qe.create(this.#n),{publicCid:n,privateCid:o,privateDataHash:i}=await e.getDatasetInfo(this.#e);if(this.#t=await t.fetchPublicDataset(n),!this.#o){const s=await t.fetchPrivateDataset(this.#e,o,i);this.#t=this.#t.map((a,c)=>({...a,...s[c]})),this.#o=!0}}}async purchase(){this.#i||(await Q.getInstance().purchase(this.#e,this.#r),this.#i=!0)}async query(e){await this.#a();const t=le(cr(e),[this.#t]);return Array.isArray(t)?t:[]}}class $o{async get(e){return Pe.load(e)}async list(){return(await Q.getInstance().listCollections()).map(t=>({id:t.address,name:t.name,description:t.description,publicColumns:t.publicColumns,privateColumns:t.privateColumns,price:v.ethers.formatUnits(t.price,18)}))}}exports.FDBRegistry=Q;exports.FilecoinDataset=Pe;exports.FilecoinDatasetFactory=$o;
